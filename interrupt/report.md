# 割り込み処理 レポート　3I44 吉髙 僚眞

## 目的
割り込みとは、作業中に外部から要求された別の作業を行い、終了後に元の作業に戻ることをいう。組み込みシステムではリアルタイムな作業が要求されるため、この手法がとられることが多い。ここでは、INT0,INT1 を利用した外部割り込み、およびカウンタを利用した定間隔割り込みについて学習する。

## 実験方法/結果

## 3.外部割込

### (1) ピン配置
外部割り込み端子 INT0 は `4` 番ピンに配置され、PD2 と共用している。

### (2) 割り込み許可（ステータスレジスタ SREG I ビット）
SREG レジスタの I ビットは割り込み機能全般を許可するビットである。割り込みを使用するには I ビットを `1` にしておく必要がある。I ビットは割り込みが生じたときに `0` （無効）になるので、（処理終了後）`RETI` 命令によって１（有効）に戻す。また、 `SEI` 命令で１に、 `CLI`命令で０にすることもできる。（C 言語では sei()、cli()である）

### (3) 外部割り込み要因（外部割り込み制御レジスタ A EICRA）
INT0 端子の割り込み要因を設定する。例えば、立ち下りエッジを割り込み要因として検出するには、ISC01,ISC00 を、それぞれ`1`，`0` にすればよい。（立ち下がりエッジとは INT0 端子が High レベルから Low レベルに変化することをいう）

### (4) 外部割り込みマスク（外部割り込みマスクレジスタ EIMSK）
割り込みを使用するには、割り込み機能全般の許可ビット（SREG の I ビット）の他に、割り込みデバイス毎にも割り込みを有効にする必要がある。INT0 外部割り込みでは INT0 ビット（ 1 ビット目）を`1`にする。検出方法は EICRA
の`ISC01`，`ISC00`ビットで設定する。


### 3.4 サンプルプログラムの実行

```c
#include <asf.h> //int.c
void interrupt_init(void);
void io_init(void);
int main (void)
{
	io_init(); //IO ポート設定
	interrupt_init(); //外部割り込み設定
	sei(); //割り込み機能全体を許可
	while(1); //通常処理
	return 0;
}
ISR(INT0_vect) //INT0 割り込みサービスルーチン
{ //INT0_vect は割り込みベクタ番号
	cli(); //割り込み機能全体を禁止
	PORTB ^= 0b00100000;
	// +--------- PB5 の出力を反転
	sei(); //割り込み機能全体許可
	return;
}
void interrupt_init(void) //外部割り込み設定
{
	EICRA = 0b00000010; //割り込み制御レジスタ
	// ++----- ISC01,ISC00 立ち下がりエッジ検出
	EIMSK = 0b00000001; //割り込みマスクレジスタ
	// +----- INT0 割り込み有効
	return;
}
void io_init(void) //IO ポート設定
{
	DDRB = 0b00100000;
	// +---------- PB5 を出力に設定
	DDRD = 0b00000000;
	// +------- PD2 を入力に設定（INT0,PD2 共用端子）
	PORTD = 0b00000100;
	// +------- PD2 をプルアップ（INT0,PD2 共用端子）
	return;
}
```

### 3.5 検出エッジの変更

```c
void interrupt_init(void)
{
	EICRA = 0b00000011; //割り込み制御レジスタ ここを変更
	// ++----- ISC01,ISC00 立ち下がりエッジ検出
	EIMSK = 0b00000001;
	// +----- INT0 割り込み有効
	return;
}
```

Table12-2より rising edgeがISC01, ISC00をそれぞれ1,1にする

### 3.6 スイッチの追加

Table13-1より ISC11, ISC10をそれぞれ1, 0にする The falling edgeより

```c
#include <asf.h> //int.c
void interrupt_init(void);
void io_init(void);
int main (void)
{
	io_init(); //IO ポート設定
	interrupt_init(); //外部割り込み設定
	sei(); //割り込み機能全体を許可
	while(1); //通常処理
	return 0;
}
ISR(INT0_vect) //INT0 割り込みサービスルーチン
{ //INT0_vect は割り込みベクタ番号
	cli(); //割り込み機能全体を禁止
	PORTB ^= 0b00100000;
	// +--------- PB5 の出力を反転
	sei(); //割り込み機能全体許可
	return;
}
ISR(INT1_vect)
{
	cli(); //割り込み機能全体を禁止
	PORTB ^= 0b00100000;
	// +--------- PB5 の出力を反転
	sei(); //割り込み機能全体許可
	return;
}

void interrupt_init(void) //外部割り込み設定
{
	EICRA = 0b00001010; //割り込み制御レジスタ
	// ++----- ISC11, ISC10 ISC01,ISC00 立ち下がりエッジ検出
	EIMSK = 0b00000011; //割り込みマスクレジスタ
	// +----- INT0 割り込み有効
	return;
}
void io_init(void) //IO ポート設定
{
	DDRB = 0b00100000;
	// +---------- PB5 を出力に設定
	DDRD = 0b00000000;
	// +------- PD2 を入力に設定（INT0,PD2 共用端子）
	PORTD = 0b00001100;
	// +------- PD2 をプルアップ（INT0,PD2 共用端子）
	return;
}
```

## 4.タイマ／カウンタモジュールを用いた定間隔割り込み

### 4.1データシートの読み取り

### (1) 概要
タイマ／カウンタ０は`8`ビットのモジュールである。

### (2) クロックソース
動作クロックは TCCR0B の CS02~CS00 ビットで設定された比で分周された後（プリスケーラ）、タイマ／カウンタ０に入力される。たとえば、この値を 011 とすると動作クロック（clkI/O）が 20MHz（周期`0.05`us）のとき、`3.2`us (0.05 × 64) ごとにカウントアップする。


### (3) CTCモード
WGM02 WGM01 WGM00 ビットが`0, 1, 0`のとき CTC（コンペアマッチ）モードとなる。OCR0A はタイマ／カウンタ０(TCNT0)の 値を示す。カウンタの値は OCR0A と一致したら、`0` に戻る。また、このとき OC0A 割り込みフラグ（OCF0A）がセットされ、割り込みが発生する。（２）の例ではOCR0A `32` にをセットすると 32us 毎に割り込みが発生することになる。
注、コンペアマッチとは設定した値とカウンタの値とが一致する条件をいう。


### (4) 割り込みマスク
`OCIE0A`ビット（`1`ビット目）が１のとき、タイマ／カウンタ０コンペアマッチ A の割り込みが有効となる。


### 4.2 サンプルプログラムの実行
```c
#include <asf.h> //ctc.c
void io_init(void);
void timer0_ctcmode_init(uint8_t top);
int main (void)
{
	io_init(); //IO ポート設定
	timer0_ctcmode_init( 10 ); //タイマ／カウンタ 0ＣＴＣモード割り込み設定
	sei(); //割り込み許可
	while(1); //通常処理
	return 0;
}
ISR(TIMER0_COMPA_vect) //タイマ／カウンタ 0 割り込みサービスルーチン
{ //TIMER0_COMPA_vect は割り込みベクタ
	cli(); //多重割り込み禁止
	PORTD ^= 0b00000001;
	// +---- PD0 の出力を反転
	sei(); //割り込み許可
}
void timer0_ctcmode_init(uint8_t top) //タイマ／カウンタ 0 ＣＴＣモード割り込み設定
{
	// タイマ／カウンタ 0 比較レジスタ A
	OCR0A = top; //タイマ／カウンタ 0 最大値
	// タイマ／カウンタ 0 制御レジスタ A
	TCCR0A = 0b00000010;
	// || ++ WGM01 WGM00 CTC モード
	// ++-------COM0A1 COM0A0 OC0A 端子出力 OFF
	// タイマ／カウンタ 0 制御レジスタ B
	TCCR0B = 0b00000011;
	// | |+++ CS02 CS01 CS00 プリスケーラ 64 分周
	// | +--- WGM02 CTC モード
	// +------- FOC0A 0(CTC モード)
	// タイマ／カウンタ 0 割り込みマスクレジスタ
	TIMSK0 = 0b00000010;
	// +- OCIE0A コンペアマッチ A 割り込み有効
}
void io_init(void) //IO ポート設定
{
	DDRD = 0b00000001;
	// +----- PD0 を出力に設定
	PORTD = 0b00000001;
	// +----- PD0 に 1 を出力（動作テスト）
}
```

求め方メモ
クロックソース
分周×周期で何秒でカウントアップするかを求める
クロックソース×10 = 32

10 ->カウンタトップ
